// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * Leasing
 *
 * The leasing products enables customers to finance equipment purchases using the leased item as collateral when necessary
 *
 * API version: 12.0.0
 */

package openapi


import (
	"fmt"
)


// Devicetypevalues : >  * `Securecardreader` - Secure card reader attached to the customer device  * `Nonsecurecardreader` - Non-secure card reader attached to the customer device.  * `Mobile` - Mobile phone  * `Tablet` - Tablet  * `Personalcomputer` - Personal computer  * `Othernational` - Other device defined at national level  * `Otherprivate` - Other device defined in a private way.  * `Wearable` - Wearable device.  * `Vehicle` - Vehicle.  * `Embedded` - Embedded in a device.  * `Keyfob` - Key Fob  * `Jewellery` - Jewellery  * `Sticker` - Sticker  * `Gamingdevice` - Gaming Device  * `Watch` - Watch  * `Unknown` - Device type unknown  * `BiometricDevice` - A biometric device is a security identification and authentication device. Such devices use automated methods of verifying or recognising the identity of a living person based on a physiological or behavioral characteristic. https://en.wikipedia.org/wiki/Biometric_device   
type Devicetypevalues string

// List of Devicetypevalues
const (
	SECURECARDREADER Devicetypevalues = "Securecardreader"
	NONSECURECARDREADER Devicetypevalues = "Nonsecurecardreader"
	MOBILE Devicetypevalues = "Mobile"
	TABLET Devicetypevalues = "Tablet"
	PERSONALCOMPUTER Devicetypevalues = "Personalcomputer"
	OTHERNATIONAL Devicetypevalues = "Othernational"
	OTHERPRIVATE Devicetypevalues = "Otherprivate"
	WEARABLE Devicetypevalues = "Wearable"
	VEHICLE Devicetypevalues = "Vehicle"
	EMBEDDED Devicetypevalues = "Embedded"
	KEYFOB Devicetypevalues = "Keyfob"
	JEWELLERY Devicetypevalues = "Jewellery"
	STICKER Devicetypevalues = "Sticker"
	GAMINGDEVICE Devicetypevalues = "Gamingdevice"
	WATCH Devicetypevalues = "Watch"
	UNKNOWN Devicetypevalues = "Unknown"
	BIOMETRIC_DEVICE Devicetypevalues = "BiometricDevice"
)

// AllowedDevicetypevaluesEnumValues is all the allowed values of Devicetypevalues enum
var AllowedDevicetypevaluesEnumValues = []Devicetypevalues{
	"Securecardreader",
	"Nonsecurecardreader",
	"Mobile",
	"Tablet",
	"Personalcomputer",
	"Othernational",
	"Otherprivate",
	"Wearable",
	"Vehicle",
	"Embedded",
	"Keyfob",
	"Jewellery",
	"Sticker",
	"Gamingdevice",
	"Watch",
	"Unknown",
	"BiometricDevice",
}

// validDevicetypevaluesEnumValue provides a map of Devicetypevaluess for fast verification of use input
var validDevicetypevaluesEnumValues = map[Devicetypevalues]struct{}{
	"Securecardreader": {},
	"Nonsecurecardreader": {},
	"Mobile": {},
	"Tablet": {},
	"Personalcomputer": {},
	"Othernational": {},
	"Otherprivate": {},
	"Wearable": {},
	"Vehicle": {},
	"Embedded": {},
	"Keyfob": {},
	"Jewellery": {},
	"Sticker": {},
	"Gamingdevice": {},
	"Watch": {},
	"Unknown": {},
	"BiometricDevice": {},
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v Devicetypevalues) IsValid() bool {
	_, ok := validDevicetypevaluesEnumValues[v]
	return ok
}

// NewDevicetypevaluesFromValue returns a pointer to a valid Devicetypevalues
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewDevicetypevaluesFromValue(v string) (Devicetypevalues, error) {
	ev := Devicetypevalues(v)
	if ev.IsValid() {
		return ev, nil
	}

	return "", fmt.Errorf("invalid value '%v' for Devicetypevalues: valid values are %v", v, AllowedDevicetypevaluesEnumValues)
}



// AssertDevicetypevaluesRequired checks if the required fields are not zero-ed
func AssertDevicetypevaluesRequired(obj Devicetypevalues) error {
	return nil
}

// AssertDevicetypevaluesConstraints checks if the values respects the defined constraints
func AssertDevicetypevaluesConstraints(obj Devicetypevalues) error {
	return nil
}
